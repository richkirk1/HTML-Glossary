import components.map.Map;
import components.map.Map2;
import components.sequence.Sequence;
import components.sequence.Sequence2L;
import components.set.Set;
import components.set.Set2;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * Put a short phrase describing the program here.
 *
 * @author Richard Kirk
 *
 */
public final class Glossary {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private Glossary() {
    }

   c
    public static void outputHeaderIndex(SimpleWriter out) {
        /*
         * Opening tags of the HTML index file.
         */
        out.println("<html><head><title>Glossary</title></head><body>");
        out.println("<h2>Glossary</h2>");
        out.println("<hr>");
        out.println("<h3>Index</h3>");
    }

    /**
     *
     * @param out
     *            the output stream
     * @param terms
     *            the queue of glossary terms in alphabetical order
     * @updates out.content
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "body" tags]
     */
    public static void outputBodyIndex(SimpleWriter out,
            Sequence<String> terms) {
        /*
         * Loop through the sequence of terms that are in alphabetical order.
         */
        for (int pos = 0; pos < terms.length(); pos++) {
            /*
             * Create the term.
             */
            String term = terms.entry(pos);
            /*
             * Put it in the list and create its link.
             */
            out.println("<li>");
            out.println("<a href=\"" + term + ".html\">" + term + "</a>");
            out.println("</li>");
        }
        out.println("</ul>");
    }

    /**
     * Outputs the "closing" tags in the index HTML file. These are the expected
     * elements generated by this method:
     *
     * </ul>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void outputFooterIndex(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";
        /*
         * Closing tags of the HTML index file.
         */
        out.println("</ul>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Outputs the "opening" tags in the respective term's HTML file. These are
     * the expected elements generated by this method:
     *
     * <html><head><title>{@code term}</title></head>
     * <h2><b><i><font color="red">{@code term}</font></i></b></h2>
     *
     * @param out
     *            the output stream
     * @param term
     *            name of the term the page is for
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    public static void outputHeaderTerm(SimpleWriter out, String term) {
        /*
         * Opening tags of the HTML index file.
         */
        out.println("<html><head><title>" + term + "</title></head>");
        out.println("<h2><b><i><font color=\"red\">" + term
                + "</font></i></b></h2>");
    }

    /**
     * Outputs the definition of the glossary term, linking to other golssary
     * terms. These are the expected elements generated by this method:
     *
     * <blockquote> {@code Map.Pair.value()} </blockquote>
     *
     * @param out
     *            the output stream
     * @param glossaryTerm
     *            a term with a corresponding definition.
     * @param termsList
     *            list of all the terms in the glossary.
     * @updates out.content
     * @requires [the root of channel is a <channel> tag] and out.is_open
     * @ensures out.content = #out.content * [the HTML "body" tags]
     */
    public static void outputTermDefinition(SimpleWriter out,
            Map.Pair<String, String> glossaryTerm, Set<String> termsList) {
        /*
         * Break the definition into its components, split by separators in
         * previous conditions.
         */
        Sequence<String> definition = stringToSequence(glossaryTerm.value());
        out.println("<blockquote>");
        for (int pos = 0; pos < definition.length(); pos++) {
            /*
             * Create a value to hold a word or separator.
             */
            String wordOrSeparator = definition.entry(pos);
            /*
             * If the word is contained in the terms list, link it to its
             * corresponding term. If not, output like normal.
             */
            if (termsList.contains(wordOrSeparator)) {
                out.print("<a href=\"" + wordOrSeparator + ".html\">"
                        + wordOrSeparator + "</a>");

            } else {
                out.print(wordOrSeparator);
            }
        }
        out.println("</blockquote>");
    }

    /**
     * Outputs the "closing" tags in the respective term's HTML file. These are
     * the expected elements generated by this method:
     *
     * <hr>
     * <p>
     * Return to <a href="index.html">index</a>
     * </p>
     * </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @requires out.is_open
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     */
    public static void outputFooterTerm(SimpleWriter out) {
        assert out != null : "Violation of: out is not null";
        assert out.isOpen() : "Violation of: out.is_open";
        /*
         * Closing tags of the HTML index file.
         */
        out.println("<hr>");
        out.println("<p>Return to <a href=\"index.html\">index</a>.</p>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     *
     * Creates a sequence containing either strings of separator characters(' ',
     * '\n', '\r', ',') and words of a definition.
     *
     * @param str
     *            the string to split into words and separators.
     * @return the sequence of words and separators
     * @ensures stringToSequence = [0, position) + separators + ... + (position,
     *          str.length)
     */
    public static Sequence<String> stringToSequence(String str) {
        /*
         * Create the list of separators.
         */
        Set<Character> separators = new Set2<>();
        separators.add(' ');
        separators.add('\n');
        separators.add(',');
        separators.add('\r');
        Sequence<String> strSeq = new Sequence2L<>();
        int position = 0;
        /*
         * Loop through every position in the string.
         */
        while (position < str.length()) {
            /*
             * Find a word or separator.
             */
            String token = nextWordOrSeparator(str, position, separators);
            /*
             * Change position to where the token ends.
             */
            position += token.length();
            /*
             * Add the string to the sequence
             */
            strSeq.add(strSeq.length(), token);
        }
        return strSeq;
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    public static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";
        String nextWordOrSeparator = "";
        /*
         * Initialize a max index of a word or separator to be the position
         * passed.
         */
        int maxIndx = position;
        /*
         * The characters are not in the separators Set, keep adding characters
         * until one is found. Likewise, if the position starts at a separator,
         * add separators to the string unless a character not in the set is
         * reached.
         */
        if (!separators.contains(text.charAt(position))) {
            while (maxIndx < text.length()
                    && !separators.contains(text.charAt(maxIndx))) {
                maxIndx++;
            }

        } else {
            while (maxIndx < text.length()
                    && separators.contains(text.charAt(maxIndx))) {
                maxIndx++;
            }
            nextWordOrSeparator = text.substring(position, maxIndx);
        }
        /*
         * Return the word or separator from its starting position to the end of
         * the string to a character not of its "type".
         */
        nextWordOrSeparator = text.substring(position, maxIndx);
        return nextWordOrSeparator;
    }

    /**
     * Returns the mapping of all terms and definitions read from {@code input},
     * consisting of a single term on the first line and its definition on the
     * next one or more lines (terminated by an empty line).
     *
     * @param input
     *            source of strings, one per line
     * @return mapping of all terms and definitions read from {@code input}
     * @requires input.is_open {@code input} contains the first term on a single
     *           line followed by its definition on one or more lines and then
     *           terminated with an empty line.
     * @ensures <pre>
     * input.is_open  and  input.content = <>  and
     * glossaryMap = mapping of single term line from {@code input} and its
     * following definition.
     * </pre>
     */
    public static Map<String, String> parseFile(SimpleReader input) {
        assert input != null : "Violation of: input is not null";
        assert input.isOpen() : "Violation of: input.is_open";
        /*
         * Initialize a set to store the strings per line from a file.
         */
        Map<String, String> glossaryMap = new Map2<String, String>();

        String term = "";
        String definition = "";
        String temp = "";
        /*
         * While there are lines in the file, add those lines to the Set.
         */
        while (!input.atEOS()) {
            /*
             * Receive the first line as a term
             */
            term = input.nextLine();
            /*
             * While the next line is not only an empty character, add that
             * string of lines to the definition of its corresponding term.
             */
            temp = input.nextLine();
            while (!temp.isEmpty()) {
                definition += temp;
                temp = input.nextLine();
            }
            glossaryMap.add(term, definition);
            definition = "";
        }

        return glossaryMap;
    }

    /**
     *
     * @param terms
     *            set of terms to organize alphabetically.
     * @return queue of the {@code glossaryMap} in alphabetical order for future
     *         use.
     * @requires
     * @ensures sequence(0) <= sequence(1) <= sequence(2) <= ... <= sequence(n)
     */
    public static Sequence<String> alphabetize(Set<String> terms) {
        /*
         * Create two temporary sets to loop through to alphabetize a sequence.
         */
        Set<String> temp1 = terms.newInstance();
        Set<String> temp2 = terms.newInstance();
        temp1.transferFrom(terms);
        Sequence<String> alphabeticalSequence = new Sequence2L<>();
        /*
         * Set an initial smallest lexicographical string to the first removed
         * in a set. Then, loop through the rest of the elements and determine
         * if any are lexicographically less. The closest to a will be added to
         * the front of the sequence.
         */
        while (temp1.size() > 0) {
            /*
             * Initial smallest.
             */
            String earliestTerm = temp1.removeAny();
            temp2.transferFrom(temp1);
            /*
             * Loop through the rest of the values and determine if the initial
             * was the smallest.
             */
            while (temp2.size() > 0) {
                String term = temp2.removeAny();
                if (earliestTerm.compareTo(term) <= 0) {
                    temp1.add(earliestTerm);
                    earliestTerm = term;
                } else {
                    temp1.add(term);
                }
            }
            alphabeticalSequence.add(0, earliestTerm);
            terms.add(earliestTerm);
        }

        return alphabeticalSequence;
    }

    /**
     *
     * @param glossaryMap
     *            the map of terms to their definitions, like a glossary
     * @return the set of terms given by the map.
     * @ensures setOfTerms = {glossaryMap.pair.key()'s}
     */
    public static Set<String> setOfTerms(Map<String, String> glossaryMap) {
        Map<String, String> temp = glossaryMap.newInstance();
        Set<String> terms = new Set2<>();
        temp.transferFrom(glossaryMap);
        while (temp.size() > 0) {
            Map.Pair<String, String> pair = temp.removeAny();
            String term = pair.key();
            terms.add(term);
            glossaryMap.add(pair.key(), pair.value());
        }
        return terms;
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {
        SimpleReader in = new SimpleReader1L();
        /*
         * Create a SimpleWriter object to receive and display information from
         * console.
         */
        SimpleWriter consoleOut = new SimpleWriter1L();
        /*
         * Receive user input.
         */
        String file = "C:\\Users\\Rich Kirk\\Desktop\\Test";
        SimpleWriter fileOut = new SimpleWriter1L(file + "\\index.html");
        /*
         * Print out header for index.
         */
        outputHeaderIndex(fileOut);
        /*
         * Parse file into a map.
         */
        Map<String, String> glossaryMap = parseFile(
                new SimpleReader1L("data\\terms.txt"));
        /*
         * Compile list of terms in the glossary.
         */
        Set<String> termsList = setOfTerms(glossaryMap);
        /*
         * Create an alphabetic queue of the terms to display on the index page.
         */
        Sequence<String> alphabeticalTerms = alphabetize(termsList);
        /*
         * Print out list of terms for body of index page.
         */
        outputBodyIndex(fileOut, alphabeticalTerms);
        /*
         * Create temp to loop through.
         */
        Map<String, String> temp = glossaryMap.newInstance();
        temp.transferFrom(glossaryMap);
        while (temp.size() > 0) {
            /*
             *
             */
            Map.Pair<String, String> pair = temp.removeAny();
            /*
             * Remove an alphabetical term.
             */
            String term = alphabeticalTerms.entry(temp.size());
            /*
             * Create an extension to store the term html in.
             */
            String fileExt = term.replaceAll(" ", "_");
            /*
             * Create the file writer to write to.
             */
            SimpleWriter termFileOut = new SimpleWriter1L(
                    file + "\\" + fileExt + ".html");
            /*
             * Print out header for respective term.
             */
            outputHeaderTerm(termFileOut, pair.key());
            /*
             * Print out body for respective term.
             */
            outputTermDefinition(termFileOut, pair, termsList);
            /*
             * Print out footer for respective term.
             */
            outputFooterTerm(termFileOut);
            /*
             * Add the temp values back to the original map.
             */
            glossaryMap.add(pair.key(), pair.value());
        }
        /*
         * Print out footer for index.
         */
        outputFooterIndex(fileOut);
        /*
         * Close input and output streams
         */
        in.close();
        consoleOut.close();
    }
}
